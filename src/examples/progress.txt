11/25/16
* fixed emacs, git pulled to both repos, opened file, opened all relevant tabs
* checked buffer w/ coq up to point of last commit
* coq fails on line 2854. i don't know why

-----

12/19/16
did
- reread emails 
- reread thesis 
  - how does HMAC-DRBG work?
  - how does the proof work?
- what's left to prove?
- skim code

TODO
- what do i need to comment out to get it to compile
- look at last three commits
- deep dive into problem w proof (and be able to explain it)
  - why is it obviously true
  - why is it hard to prove
    	something about sampling k
  - why isn't it compiling. breaks *after* the new stuff
    - if i bisect, what's the most recent commit it compiles on?

looks like the main ones left are Gi_normal_rb_eq, PRF_Advantages, and Gi_rb_bad_eq_(i)

new TODO
- ping adam?
- start documenting code as i read it
- start documenting what my thesis got wrong
- review existing proofs and fcf techniques
- email andrew about dates/times

- also formalize proof of backtracking resistance?

------

1/2/17
working notes
1. Gi_normal_rb_eq
- need to deal with calls < i, calls = i, calls > i. which one is the hard case?
- what's the name of the theorem that I'm trying to prove in the written proof?
- how do I use that to prove the overall thing?
- did I already try this proof, and what parts of it did or did not work?

calls < i
- watch out for quantifiers and IH
- oracleMap vs. oracleCompMap_inner?
- start with calls=0, i as abstract?
- what were the intermediate games I did to get Gen_loop_last?
- why are we updating v on the first call? thought it was noV
- iirc it was hard to prove the k was irrelevant, e.g. if it's present in Gen_loop
- so on what call do we actually use the k?
- what's the structural problem with RB-substitution again?

calls = i
- how am i breaking it up into calls < i, = i, > i?
- what theorem structure is common between them?
- 

calls > i
- assuming calls = i works out, has same incoming state?
- so should it be a simple induction? 

- so the problem is between GenUpdate_rb_intermediate (oracleMap, calls < i) and
GenUpdate_oc (oracleCompMap_inner, calls = i)
calls = 0   1   2   3
        RB  RB  PRF PRF <-- oracleMap (S 0)
        RB |RB| PRF PRF <-- oracleCompMap 0, use RB when i=1? 
(numbering may be off)

oracleMap (i = S 1) (calls = 0) l does 
bits <-$ Gen_loop_rb n;
ret (bits, v)

and oracleCompMap (i = 1) (calls = 0) rb_oracle l does
v <-$ |OC_query v0|; 
[bits, v'] <-$ Gen_loop_oc v n;
k <-$ |OC_query (v' || 00)|
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
[bits, v'] <-$ Gen_loop_oc v n;
k <-$ RndK;
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
v' <-$ RndV; // roughly, since the above loop re-samples v a bunch of times ind.?
bits <-$ Gen_loop_rb n;
k <-$ RndK;
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
v' <-$ RndV; // roughly, since the above loop re-samples v a bunch of times ind.?
bits <-$ Gen_loop_rb n;
k <-$ RndK;
ret (bits, (k', v'))

- how did i get rid of the v re-sampling??
- there's also an Instantiate to deal with
- TODO ^ numbering is wrong

- is doing (S i) really okay when the 0th call gets special treatment (no v)?

stepping through Gi_normal_rb_eq
- replace Oi_oc' with Oi_oc'': what's the difference? 
  is that lemma (oracleCompMap_rb_instantiate_inner) fully proven?
  pulls k and kv updating to the beginning of a call, BEFORE bit generation
- replace Oi_oc'' with Oi_oc'''  
  uses GenUpdate_rb_intermediate_oc_v on any call <= i
  should this be GenUpdate_rb (NOT intermediate)?
  takes in (k,v) state but does not use or update k
- oraclecompmap_rb_instantiate_inner requires some changes in Oi_oc'? why?

---

TODO
- get the code to compile
  - why are Gi_rf_rb_close, Gi_normal_rb_eq, and the inner lemma not checking?
  - bisect/revert to earlier commits
  - from july 30-august 12?? 21 commits
  - why does the aug 4 proof idea (pull out instantiate) not work?
  - why do i need `list <> nil` assumptions?
- understand prev. work on proof and where it broke
  - how did I get rid of the v-sampling? read the earlier defs
- review easier induction proofs
  - e.g. why doesn't the same approach in Gi_normal_prf_eq (?) work?
- practice explaining the proof (e.g. can we deal with no v-updating?)

- figure out why the other strategies from the email don't work:
  1. changing the structure so (k,v) are updated breaks Gi_normal_prf_eq--why?
  2. selectively skipping the instantiate statements--does my proof work?
     why does it break the double induction?

- make another attempt at proof
- start documenting code as i read it
- look at previous commits
- forward email to adam about the problem
- email andrew, matt, and adam about the status of the proof

explain the following lemmas:
1. Gi_normal_rb_eq
2. PRF_Advantages
3. Gi_rb_bad_eq_(i)

- start documenting what my thesis got wrong
- review existing proofs and fcf techniques
- clean up old comments from file		

DONE
- read the proof in commit 3; commented (sampling in call i seems wrong?)
- read email to adam
- figure out the theorem statement and problem with structure
- deep dive into problem w proof (and be able to explain it)
  - why is it obviously true
  - why is it hard to prove? something about sampling k
- send email

need to update TODOs above
also see changes in HMAC_DRBG_nonadaptive.v

-----

1/26/17

it's been 24 days (3.5 weeks). i spent that time hacking on penrose and writing/practicing the talk, so i'm not sure what's going on.

read:
- notes from last meeting X
- old email to adam X
- proof i wrote in file X
- email to andrew X
- code i wrote months ago (did not do)

intuition: the outputted bits and kv at the end should follow the same distribution for both executions because in the first execution, the kv (uniformly randomly sampled) are just passed straight thru to the PRF calls which then use and update them. and in the second execution, they are uniformly randomly sampled, passed thru to the RB calls (whicn don't use them) and the special RB call (which doesn't use them but uniformly randomly sampled them again) and then to the PRF calls (which use and update them in the same manner as in the first execution.

the lemma in question is Gi_normal_rb_eq
the proposed proof resides at line 2604

reading proof:
- did i deal with the calls=0 special case? 
- what if i=0? that's fine, we start with calls < i \/ calls = i, which deals w it
- induction statement isn't quite right since we do induct-then-destruct. check this while setting up
- what should the intermediate/final postconditions be besides eq? make sure they match up
- being able to prove k irrelevant + swap it to the back seems like a major lemma. TODO confirm that it's true for Gen_loop_last (whatever that is)
- what are the intermediate games i need to get k and v in the right place in the special RB execution, or get rid of the extra v-sampling?
  - getting rid of v-sampling seems like a major lemma too. it works bc Gen_loop_last doesn't actually use the sampled v that's passed in (if n > 0). the v'' are resampled
- i think last time i *was* able to match the IH correctly on calls<i. i should test that i can do it again
- what is gen_loop_last? do i need an intermediate game to change that? what do i change it to?

answer:
- how do i make the code compile? add a bunch of admits to the ...i_neq_0 lemma X
- what was the problem? extra k,v sampling X

- what was the intuition behind the paper proof? k dealt with by IH, v dealt with by irrelevance X
- what's all that stuff i wrote above? (X doesn't matter)

- ***what do i need to prototype to get it to work? 
  - theorem for Gi_normal_rb, theorem with hypothesis (calls < i \/ calls = i), induct and destruct, apply IH successfully, second theorem on calls > i
  - intermediate games/lemmas to get rid of v-sampling in special RB call, move k to end in calls < i, and maybe for Gen_loop
- What's the minimum (and maximum) goal for the meeting this thursday afternoon?
  - prototype all of the above and start filling in proofs
- what intermediate goals should i set for sunday, monday, tuesday, wednesday, thursday?
  - mon: interview prep / tues, wed, thurs: prototype 
- what goals should i be setting afterward? e.g. february, march, april, may
  - unclear, what else is left to prove?

- figure out what's up w/ the "no element in the list is 0" assumption. casework?
- what was i prototyping last time?
- why didn't what i tried last time work?
- how much of that can i salvage?
- am i fundamentally misunderstanding something? e.g. the goal, FCF, the proof, probability theory, distributions, sampling

this context switching is very difficult...

-------
2/1/17
- i will have worked on this proof for a grand total of 7+3 = 10 hours since last time

proof resides at line 2607

try to bridge GenUpdate_oc_instantiate (oracle RB) and GenUpdate_rb_intermediate_oc (just sample bits, don't update state)
Oi_oc': normal, uses oracle on ith call
Oi_oc'': hardcode oracle everywhere to be RB oracle, normal RBs now update v
  but can we really prove this equivalence for "normal RBs now update v"?
  TODO look at proof (name = ?)
Oi_oc''': removes all extra k,v sampling from beginning of functions

TODO
- can we really prove this equivalence for "normal RBs now update v"?
- what part of the proof didn't work?? what do i need to change for my proof??

- oh, i see the second bullet point was supposed to be answered by the first bullet point. i had specifically just *added* the any_v parameter in the main theorem (oracleMap_oracleCompMap_equiv_modified) and the "normal RBs now update v" change in GenUpdate_RB_intermediate_oc_v in order to address.... some problem. new sub-questions:
  - what exactly was the problem?
    on the (S i)th call, Oi_prg just gens random bits, does NOT update state
    on the ith call, Oi_oc''' gens random bits and ONLY updates v
  - will this work?
  - what do i need to propagate (and fix) in the rest of the code?
    block numbers != 0?
  - there was an Oi_oc4 at some point. not sure why I added or removed it
  - wait. aug 11 commit was complaining about why i ADDED _v. it seemed to *break* something. then in a commit after that, i had figured out why i had added it?
  - problem: GenUpdate_noV_oc_k (and variants with oracle sub'd) DO update the v to be the last block generated, whereas GenUpdate_rb (and variants) just generate the random bits and pass the state thru
  - so... does this actually matter WRT the postconditions? what part of my (paper) proof does this break? (if any) @@@

- step thru Gi_normal_rb_eq
  - what was I doing previously? 
  - why didn't it work? what parts of it are broken? what parts of the prev code need to change?
  - what is this any_v business?
  - how much of it can I salvage?
  - what do I need to change to make it work?
- what is the FIRST THING i need to define or do in Gi_normal_rb?
  - figure out what Oi_oc', Oi_oc'', Oi_oc''' are, and if i can reuse them
  - figure out what comes after them
  - figure out what the main lemmas are that are used
- do the following
  - theorem: inside Gi_normal_rb
  - theorem: with hypothesis (calls < i \/ calls = i)
  - tactic: induct and destruct
  - tactic: apply IH successfully, 
  - theorem: second one on calls > i
  - definitions: intermediate games/lemmas to get rid of v-sampling in special RB call
  - definition: move k to end in calls < i, and maybe for Gen_loop
  - understand the stuff I wrote last time
- write email

- PLEASE leave a high-level comment on top of a lemma describing 
1. where it's used 
2. what it uses
3. what it's for
4. what the proof idea is

future: @@@ is the active area of what i'm working on

-------

2/15/17

- best-case scenario: i try the fix and the top-level proof works entirely in coq! <-- GOALS
- OK-case scenario: i try the fix and the top-level proof might work (might break but can be salvaged), and other stuff might break, but i don't know for sure
- worst-case scenario: i try the fix and the top-level proof doesn't work for some new reason, AND other stuff breaks, and i don't know how to fix the top-level proof

done so far
- read commits
- read email
- understand problem
- review proof idea
- look at thesis (proof tree and top-level proof outline)
- figure out what needs to be changed
- figure out what else (besides the top-level proof) might break
- figure out if the top-level proof will break

from my email: what does this mean??
> - Changing the structure so (k,v) are updated. I can't change it because I need GenUpdate_rb_intermediate and the corresponding GenUpdate_rb_intermediate_oc to not change the (k,v) state. Otherwise, it will make the following similar theorem false, and I've already proved it. 

> Lemma Gi_normal_prf_eq : forall (i : nat),
  Pr[Gi_prg i] == Pr[Gi_prf i].

how did that proof work? looking at page 56 of my thesis:

RB RB  PRF  PRF
RB RB |PRF| PRF

it shouldn't break that proof, since the RBs are lined up, but i may need to dive into
the earlier inductions and fix some conditions

wait, but does updating v invalidate the trick for getting rid of the v-sampling??? from email 2:

> 2. the extra v-sampling doesn't matter in `calls = i` as long as the adversary never requests 0 blocks and because the random bits oracle doesn't use the sampled v. The combination of the two mean that the outputted bits are sampled uniformly at random, independently from v.

what does "every RB uses the last v" mean?

RB  RB  PRF PRF
RB |RB| PRF PRF

ok, the idea is that in the version w/o k-sampling:

(1) GenUpdate_oracle_rb ((k,v) : KV) (n : nat) : (list (Bvector eta) * KV) :=
v' <-$ {0,1}^n;
(bits, v'') <-$ Gen_loop n v';
ret (bits, (k, v''))

it doesn't matter if the v is resampled, since the input v is never used, UNLESS n=0. 
so, if we update v in all RBs, we need to extend our assumption that n_i !=0 (only for calls=i) 
to n_i != 0 (for ALL i in 1..n, where n is the length of the list of blocks).
otherwise, the trick still works.

---

something in the written proof must be wrong on calls = i. fix it:
around line 2741, oracleMap Oi_prg mistakely has Gen_loop_last updating v, when it actually does not

---

most of the earlier proofs don't touch the ideal hybrid. things that involve the idea-world game or last hybrid:
- G2_Gi_n_equal: the ideal-world game is equal to the last hybrid
- i have no idea if this change affects the identical until bad lemmas?? bad event = dups in RB oracle state
   i feel like it shouldn't affect anything b/c it still does not affect the output bits, and no one cares abt the state. maybe i'll have to fix the types and quantifiers over v somewhere
- Gi_rb_bad_collisions, Gi_rb_bad_eq_i: some intermediate lemmas may need to change

---

the top-level theorem, Gi_normal_rb_eq, currently resides at line 3332

reverting any_v: dang guys, blame works https://github.com/hypotext/fcf/blame/master/src/examples/HMAC_DRBG_nonadaptive.v
- now Gi_normal_rb compiles (what are the holes? what did i prove?)
- fix oracleCompMap_rb_instantiate_outer_i_neq_0, which still doesn't compile for unknown reasons
  (the blame is confusing too)
- should GenUpdate_RB_intermediate_oc_v be modified? or is that the right version? no, that's the right form

- modify GenUpdate_rb to use the last element of bits as v
  - maybe i should eliminate the k? (modify gen_loop_rb_intermediate. does anyone else use that)

- lol, an induction hypothesis breaks on line 705 :S
  - and rightfully so. compMap_oracleMap_rb still uses Gen_loop_rb, but maybe it should now use the other one
  - actually maybe i should change the last hybrid
  - i have no idea what the prove is trying to prove
  - maybe i should admit all things that break and check them before chasing one thing that breaks, which may require many changes...

--------

things that break: (keyword @v)
- compMap_oracleMap_rb (need to change G2 or prove it equivalent)
- (2) a case of Gi_normal_prf_eq_compspec: return types of Gen_loop and Gen_loop_inter. are different
  - do i need to change the intermediate postcondition??
  - also, bitsVEq isn't true because of the way GenUdpate_rb_intermediate_oc is defined... RIP. do we need bitsVEq? also TODO: if we *also* change GU_rb_int_oc, what else will break??
  - i added Gen_loop_rb_and_intermediate_eq though

- ok, i just also changed GenUpdate_rb_intermediate_oc to use the last v, which fixed (2)

- (3) a case in Gi_normal_rb_eq_calls_eq_i?
  that case is wrong because the k is re-sampled, so the output k's aren't equal. i suspect it's an old lemma that i don't use (it goes straight from Oi_prg to Oi_oc')

- a case now works in oracleCompMap_rb_instantiate_inner (Oi_oc' to Oi_oc''). TODO dig through the remaining cases

- made some changes in oracleMap_oracleCompMap_equiv_modified_calls_gt_i: (*)
now k's aren't equal in case. why?
also TODO the calls > i induction (why can't we use subst?)

- the sequence of rewrites: WTP Oi_prg <-> Oi_oc'.
  intermediate rewrites: Oi_oc' -> Oi_oc'' -> Oi_oc''', then Oi_prg <-> Oi_oc''' (what (*) does)

- 

TODO
- fix G2_gi_n_equal
- clone old proofs in a different file and check out how those proofs work
- PUSH THE CODE and notes before i leave
- try it and see what breaks! and fix it!
- look into detailed proof breakdowns (Oi_oc' -> Oi_oc'' -> Oi_oc''', and for i < 0 etc.)
- how much of the proof actually worked already? did it break down at any_v? and where else?

- maybe i should eliminate the k? (modify gen_loop_rb_intermediate. does anyone else use that. yes, all the Gi_rb_normal_eq intermediate lemmas use it. why?)
- fix oracleCompMap_rb_instantiate_outer_i_neq_0, which still doesn't compile for unknown reasons
  (the blame is confusing too)
