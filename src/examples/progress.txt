11/25/16
* fixed emacs, git pulled to both repos, opened file, opened all relevant tabs
* checked buffer w/ coq up to point of last commit
* coq fails on line 2854. i don't know why

-----

12/19/16
did
- reread emails 
- reread thesis 
  - how does HMAC-DRBG work?
  - how does the proof work?
- what's left to prove?
- skim code

TODO
- what do i need to comment out to get it to compile
- look at last three commits
- deep dive into problem w proof (and be able to explain it)
  - why is it obviously true
  - why is it hard to prove
    	something about sampling k
  - why isn't it compiling. breaks *after* the new stuff
    - if i bisect, what's the most recent commit it compiles on?

looks like the main ones left are Gi_normal_rb_eq, PRF_Advantages, and Gi_rb_bad_eq_(i)

new TODO
- ping adam?
- start documenting code as i read it
- start documenting what my thesis got wrong
- review existing proofs and fcf techniques
- email andrew about dates/times

- also formalize proof of backtracking resistance?

------

1/2/17
working notes
1. Gi_normal_rb_eq
- need to deal with calls < i, calls = i, calls > i. which one is the hard case?
- what's the name of the theorem that I'm trying to prove in the written proof?
- how do I use that to prove the overall thing?
- did I already try this proof, and what parts of it did or did not work?

calls < i
- watch out for quantifiers and IH
- oracleMap vs. oracleCompMap_inner?
- start with calls=0, i as abstract?
- what were the intermediate games I did to get Gen_loop_last?
- why are we updating v on the first call? thought it was noV
- iirc it was hard to prove the k was irrelevant, e.g. if it's present in Gen_loop
- so on what call do we actually use the k?
- what's the structural problem with RB-substitution again?

calls = i
- how am i breaking it up into calls < i, = i, > i?
- what theorem structure is common between them?
- 

calls > i
- assuming calls = i works out, has same incoming state?
- so should it be a simple induction? 

- so the problem is between GenUpdate_rb_intermediate (oracleMap, calls < i) and
GenUpdate_oc (oracleCompMap_inner, calls = i)
calls = 0   1   2   3
        RB  RB  PRF PRF <-- oracleMap (S 0)
        RB |RB| PRF PRF <-- oracleCompMap 0, use RB when i=1? 
(numbering may be off)

oracleMap (i = S 1) (calls = 0) l does 
bits <-$ Gen_loop_rb n;
ret (bits, v)

and oracleCompMap (i = 1) (calls = 0) rb_oracle l does
v <-$ |OC_query v0|; 
[bits, v'] <-$ Gen_loop_oc v n;
k <-$ |OC_query (v' || 00)|
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
[bits, v'] <-$ Gen_loop_oc v n;
k <-$ RndK;
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
v' <-$ RndV; // roughly, since the above loop re-samples v a bunch of times ind.?
bits <-$ Gen_loop_rb n;
k <-$ RndK;
ret (bits, (k', v'))

which simplifies to
v <-$ RndV; 
v' <-$ RndV; // roughly, since the above loop re-samples v a bunch of times ind.?
bits <-$ Gen_loop_rb n;
k <-$ RndK;
ret (bits, (k', v'))

- how did i get rid of the v re-sampling??
- there's also an Instantiate to deal with
- TODO ^ numbering is wrong

- is doing (S i) really okay when the 0th call gets special treatment (no v)?

stepping through Gi_normal_rb_eq
- replace Oi_oc' with Oi_oc'': what's the difference? 
  is that lemma (oracleCompMap_rb_instantiate_inner) fully proven?
  pulls k and kv updating to the beginning of a call, BEFORE bit generation
- replace Oi_oc'' with Oi_oc'''  
  uses GenUpdate_rb_intermediate_oc_v on any call <= i
  should this be GenUpdate_rb (NOT intermediate)?
  takes in (k,v) state but does not use or update k
- oraclecompmap_rb_instantiate_inner requires some changes in Oi_oc'? why?

---

TODO
- get the code to compile
  - why are Gi_rf_rb_close, Gi_normal_rb_eq, and the inner lemma not checking?
  - bisect/revert to earlier commits
  - from july 30-august 12?? 21 commits
  - why does the aug 4 proof idea (pull out instantiate) not work?
  - why do i need `list <> nil` assumptions?
- understand prev. work on proof and where it broke
  - how did I get rid of the v-sampling? read the earlier defs
- review easier induction proofs
  - e.g. why doesn't the same approach in Gi_normal_prf_eq (?) work?
- practice explaining the proof (e.g. can we deal with no v-updating?)

- figure out why the other strategies from the email don't work:
  1. changing the structure so (k,v) are updated breaks Gi_normal_prf_eq--why?
  2. selectively skipping the instantiate statements--does my proof work?
     why does it break the double induction?

- make another attempt at proof
- start documenting code as i read it
- look at previous commits
- forward email to adam about the problem
- email andrew, matt, and adam about the status of the proof

explain the following lemmas:
1. Gi_normal_rb_eq
2. PRF_Advantages
3. Gi_rb_bad_eq_(i)

- start documenting what my thesis got wrong
- review existing proofs and fcf techniques
- clean up old comments from file		

DONE
- read the proof in commit 3; commented (sampling in call i seems wrong?)
- read email to adam
- figure out the theorem statement and problem with structure
- deep dive into problem w proof (and be able to explain it)
  - why is it obviously true
  - why is it hard to prove? something about sampling k
- send email

need to update TODOs above
also see changes in HMAC_DRBG_nonadaptive.v

-----

1/26/17

it's been 24 days (3.5 weeks). i spent that time hacking on penrose and writing/practicing the talk, so i'm not sure what's going on.

read:
- notes from last meeting X
- old email to adam X
- proof i wrote in file X
- email to andrew X
- code i wrote months ago (did not do)

intuition: the outputted bits and kv at the end should follow the same distribution for both executions because in the first execution, the kv (uniformly randomly sampled) are just passed straight thru to the PRF calls which then use and update them. and in the second execution, they are uniformly randomly sampled, passed thru to the RB calls (whicn don't use them) and the special RB call (which doesn't use them but uniformly randomly sampled them again) and then to the PRF calls (which use and update them in the same manner as in the first execution.

the lemma in question is Gi_normal_rb_eq
the proposed proof resides at line 2604

reading proof:
- did i deal with the calls=0 special case? 
- what if i=0? that's fine, we start with calls < i \/ calls = i, which deals w it
- induction statement isn't quite right since we do induct-then-destruct. check this while setting up
- what should the intermediate/final postconditions be besides eq? make sure they match up
- being able to prove k irrelevant + swap it to the back seems like a major lemma. TODO confirm that it's true for Gen_loop_last (whatever that is)
- what are the intermediate games i need to get k and v in the right place in the special RB execution, or get rid of the extra v-sampling?
  - getting rid of v-sampling seems like a major lemma too. it works bc Gen_loop_last doesn't actually use the sampled v that's passed in (if n > 0). the v'' are resampled
- i think last time i *was* able to match the IH correctly on calls<i. i should test that i can do it again
- what is gen_loop_last? do i need an intermediate game to change that? what do i change it to?

answer:
- how do i make the code compile? add a bunch of admits to the ...i_neq_0 lemma X
- what was the problem? extra k,v sampling X

- what was the intuition behind the paper proof? k dealt with by IH, v dealt with by irrelevance X
- what's all that stuff i wrote above? (X doesn't matter)

- ***what do i need to prototype to get it to work? 
  - theorem for Gi_normal_rb, theorem with hypothesis (calls < i \/ calls = i), induct and destruct, apply IH successfully, second theorem on calls > i
  - intermediate games/lemmas to get rid of v-sampling in special RB call, move k to end in calls < i, and maybe for Gen_loop
- What's the minimum (and maximum) goal for the meeting this thursday afternoon?
  - prototype all of the above and start filling in proofs
- what intermediate goals should i set for sunday, monday, tuesday, wednesday, thursday?
  - mon: interview prep / tues, wed, thurs: prototype 
- what goals should i be setting afterward? e.g. february, march, april, may
  - unclear, what else is left to prove?

- figure out what's up w/ the "no element in the list is 0" assumption. casework?
- what was i prototyping last time?
- why didn't what i tried last time work?
- how much of that can i salvage?
- am i fundamentally misunderstanding something? e.g. the goal, FCF, the proof, probability theory, distributions, sampling

this context switching is very difficult...

-------
2/1/17
- i will have worked on this proof for a grand total of 7+3 = 10 hours since last time

proof resides at line 2607

try to bridge GenUpdate_oc_instantiate (oracle RB) and GenUpdate_rb_intermediate_oc (just sample bits, don't update state)
Oi_oc': normal, uses oracle on ith call
Oi_oc'': hardcode oracle everywhere to be RB oracle, normal RBs now update v
  but can we really prove this equivalence for "normal RBs now update v"?
  TODO look at proof (name = ?)
Oi_oc''': removes all extra k,v sampling from beginning of functions

TODO
- can we really prove this equivalence for "normal RBs now update v"?
- what part of the proof didn't work?? what do i need to change for my proof??

- step thru Gi_normal_rb_eq
  - what was I doing previously? 
  - why didn't it work? what parts of it are broken? what parts of the prev code need to change?
  - what is this any_v business?
  - how much of it can I salvage?
  - what do I need to change to make it work?
- what is the FIRST THING i need to define or do in Gi_normal_rb?
  - figure out what Oi_oc', Oi_oc'', Oi_oc''' are, and if i can reuse them
  - figure out what comes after them
  - figure out what the main lemmas are that are used
- do the following
  - theorem: inside Gi_normal_rb
  - theorem: with hypothesis (calls < i \/ calls = i)
  - tactic: induct and destruct
  - tactic: apply IH successfully, 
  - theorem: second one on calls > i
  - definitions: intermediate games/lemmas to get rid of v-sampling in special RB call
  - definition: move k to end in calls < i, and maybe for Gen_loop
  - understand the stuff I wrote last time
- write email
  - goal for email: "i prototyped it and it still seems to work, here are the main holes, i want to finish it by next week"

- PLEASE leave a high-level comment on top of a lemma describing 
1. where it's used 
2. what it uses
3. what it's for
4. what the proof idea is
